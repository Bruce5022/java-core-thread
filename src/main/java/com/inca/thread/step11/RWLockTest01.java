package com.inca.thread.step11;

import java.util.Random;

/**
 * 不加任何锁的情况,开始读了,被写程序抢到资源执行,开始写了,又可能被暂停去执行读,读写乱套了
 * 我们需要的结果是,可以同时读,但写的时候,不能读,读的时候不能写,一个写完之前,其它线程不能写
 * @author Bruce
 *
 */
public class RWLockTest01 {
	public static void main(String[] args) {
		final Queue01 q = new Queue01();
		for (int i = 0; i < 3; i++) {
			new Thread(new Runnable() {
				public void run() {
					while (true) {
						q.get();
					}
				}
			}, "读-线程" + i).start();
			
			new Thread(new Runnable() {
				public void run() {
					while (true) {
						q.put(new Random().nextInt(10000));
					}
				}
			}, "写-线程" + i).start();

		}
	}
}
//打印结果:
//	读-线程0开始读...
//	读-线程1开始读...
//	读-线程2开始读...
//	写-线程2开始写...
//	写-线程0开始写...
//	写-线程1开始写...
//	读-线程0已读完:null
//	读-线程0开始读...
//	读-线程0已读完:null
//	读-线程0开始读...
//	写-线程0已写入:42
//	写-线程0开始写...
//	读-线程1已读完:42
//	读-线程1开始读...
//	写-线程1已写入:1856
//	写-线程1开始写...
//	写-线程0已写入:7050
//	写-线程0开始写...
//	写-线程0已写入:254
//	写-线程0开始写...
//	写-线程2已写入:9903
//	写-线程2开始写...
//	读-线程1已读完:9903
//	读-线程1开始读...
//	读-线程0已读完:9903
//	读-线程0开始读...
//	写-线程1已写入:5553
//	写-线程1开始写...
//	读-线程2已读完:5553
//	读-线程2开始读...
//	写-线程2已写入:8724
//	写-线程2开始写...
//	写-线程0已写入:5112
//	写-线程0开始写...
//	读-线程2已读完:5112
//	读-线程2开始读...
//	写-线程0已写入:3778
//	写-线程0开始写...
//	读-线程2已读完:3778
//	读-线程2开始读...
//	读-线程1已读完:3778
//	读-线程1开始读...
//	写-线程2已写入:7682
//	写-线程2开始写...
//	读-线程1已读完:7682
//	读-线程1开始读...
//	读-线程0已读完:7682
//	读-线程0开始读...
//	写-线程0已写入:8569
//	写-线程0开始写...
//	读-线程0已读完:8569
//	读-线程0开始读...
//	读-线程2已读完:6956
//	读-线程2开始读...
//	写-线程1已写入:6956
//	写-线程1开始写...
